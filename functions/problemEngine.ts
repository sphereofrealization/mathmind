// Backend function: Autonomous problem generator/solver/advancer\n// Schedule: every 5 minutes (via dashboard)\nimport { base44 } from "@/api/base44Client";\n\nexport default async function handler(event, ctx) {\n  const MAX_NEW = 3;\n  const MAX_SOLVE = 4;\n  const agents = await base44.entities.SiteAgent.list("-updated_date", 50);\n\n  for (const agent of agents) {\n    if (!agent.loop_enabled) continue;\n\n    // ensure agent-specific AI exists (lightweight)\n    const ai = await ensureAgentAI(agent);\n\n    // 1) Generate new problems if queue is small\n    const openNow = await base44.entities.Problem.filter({ agent_id: agent.id, status: "open" }, "-created_date", 20);\n    if ((openNow?.length || 0) < 5) {\n      const gen = await base44.integrations.Core.InvokeLLM({\n        prompt: `Generate ${MAX_NEW} novel mathematics problems tightly aligned to this research objective.\nObjective: ${agent.objective}\nRules: prefer proof/derivation style; include enough context to be self-contained; avoid trivia; target graduate/research level where appropriate.\nReturn JSON with problems: [{title, statement, difficulty(one of introductory, intermediate, advanced, research), domain, tags:[string]}].`,\n        add_context_from_internet: true,\n        response_json_schema: { type: 'object', properties: { problems: { type: 'array', items: { type: 'object', properties: { title: { type: 'string' }, statement: { type: 'string' }, difficulty: { type: 'string' }, domain: { type: 'string' }, tags: { type: 'array', items: { type: 'string' } } }, required: ["statement"] } } } }\n      });\n      const problems = Array.isArray(gen?.problems) ? gen.problems.slice(0, MAX_NEW) : [];\n      for (const p of problems) {\n        const rec = await base44.entities.Problem.create({\n          agent_id: agent.id,\n          ai_id: ai?.id,\n          title: (p.title || '').slice(0, 180),\n          statement: String(p.statement || '').slice(0, 5000),\n          difficulty: normalizeDifficulty(p.difficulty),\n          domain: (p.domain || '').slice(0, 80),\n          status: 'open',\n          source: 'generated',\n          tags: Array.isArray(p.tags) ? p.tags.slice(0, 10) : []\n        });\n        await base44.entities.SiteAgentLog.create({ agent_id: agent.id, type: 'action', success: true, summary: `New problem: ${rec.title || rec.id}`, message: JSON.stringify({ problem_id: rec.id }) });\n      }\n    }\n\n    // 2) Try solving up to MAX_SOLVE open problems\n    const toSolve = await base44.entities.Problem.filter({ agent_id: agent.id, status: 'open' }, '-created_date', MAX_SOLVE);\n    for (const pr of toSolve) {\n      const solve = await base44.integrations.Core.InvokeLLM({\n        prompt: `Solve the following mathematics problem rigorously. Provide a step-by-step approach and then a concise final solution. Include references if any. Problem:\n${pr.statement}`,\n        add_context_from_internet: false,\n        response_json_schema: { type: 'object', properties: { approach: { type: 'string' }, solution: { type: 'string' }, result: { type: 'string' }, confidence: { type: 'number' }, references: { type: 'array', items: { type: 'string' } } } }\n      });\n      const attempt = await base44.entities.ProblemAttempt.create({\n        problem_id: pr.id, agent_id: agent.id, ai_id: ai?.id,\n        approach: String(solve?.approach || '').slice(0, 12000),\n        solution: String(solve?.solution || '').slice(0, 12000),\n        result: normalizeResult(solve?.result),\n        confidence: typeof solve?.confidence === 'number' ? solve.confidence : undefined,\n        references: Array.isArray(solve?.references) ? solve.references.slice(0, 10) : []\n      });\n\n      const solved = attempt.result === 'solved';\n      await base44.entities.Problem.update(pr.id, { status: solved ? 'solved' : 'in_progress', latest_attempt_id: attempt.id });\n      await base44.entities.SiteAgentLog.create({ agent_id: agent.id, type: 'result', success: solved, summary: `${solved ? 'Solved' : 'Attempted'}: ${pr.title || pr.id}`, message: JSON.stringify({ problem_id: pr.id, attempt_id: attempt.id, result: attempt.result }) });\n\n      // 3) Store learning to the agent's AI\n      const learningText = `Problem: ${pr.title || ''}\n${pr.statement}\n\nApproach: ${attempt.approach}\nSolution: ${attempt.solution}\nOutcome: ${attempt.result} (confidence ${attempt.confidence ?? 'n/a'})`;\n      await base44.entities.AILearning.create({ ai_id: ai.id, text: learningText, status: 'ready', visibility: 'private' });\n\n      // 4) Advancer: if solved or high confidence partial, derive a harder follow-up\n      if (solved || attempt.confidence >= 0.6) {\n        const harder = await base44.integrations.Core.InvokeLLM({\n          prompt: `Create one strictly more advanced follow-up problem that builds directly on the solution just found. Return JSON {title, statement, difficulty(one of introductory, intermediate, advanced, research), domain}.\nOriginal problem and solution:\n${pr.statement}\n---\n${attempt.solution}` ,\n          add_context_from_internet: false,\n          response_json_schema: { type: 'object', properties: { title: { type: 'string' }, statement: { type: 'string' }, difficulty: { type: 'string' }, domain: { type: 'string' } }, required: ['statement'] }\n        });\n        if (harder?.statement) {\n          const next = await base44.entities.Problem.create({\n            agent_id: agent.id, ai_id: ai.id,\n            title: (harder.title || '').slice(0, 180),\n            statement: String(harder.statement || '').slice(0, 6000),\n            difficulty: normalizeDifficulty(harder.difficulty) || escalateDifficulty(pr.difficulty),\n            domain: (harder.domain || pr.domain || '').slice(0, 80),\n            status: 'open', source: 'derived', parent_problem_id: pr.id\n          });\n          await base44.entities.ProblemAttempt.update(attempt.id, { spawned_problem_id: next.id });\n          await base44.entities.SiteAgentLog.create({ agent_id: agent.id, type: 'action', success: true, summary: `Advanced to: ${next.title || next.id}`, message: JSON.stringify({ from_problem_id: pr.id, to_problem_id: next.id }) });\n        }\n      }\n    }\n  }\n}\n\nfunction normalizeDifficulty(d) {\n  const v = String(d || '').toLowerCase();\n  if (["introductory","intermediate","advanced","research"].includes(v)) return v;\n  return undefined;\n}\nfunction escalateDifficulty(d) {\n  const order = ["introductory","intermediate","advanced","research"];\n  const i = Math.max(0, order.indexOf(String(d || '').toLowerCase()));\n  return order[Math.min(order.length - 1, i + 1)] || 'advanced';\n}\nfunction normalizeResult(r) {\n  const v = String(r || '').toLowerCase();\n  if (["solved","partial","failed"].includes(v)) return v;\n  // heuristics\n  if (v.includes('prove') || v.includes('shown')) return 'solved';\n  if (v.includes('cannot') || v.includes('open')) return 'failed';\n  return 'partial';\n}\n\nasync function ensureAgentAI(agent) {\n  const aiName = `[Agent] ${agent.name}`;\n  const list = await base44.entities.TrainedAI.filter({ name: aiName }, "-updated_date", 1);\n  let ai = list && list[0];\n  if (!ai) {\n    ai = await base44.entities.TrainedAI.create({\n      name: aiName, source_books: [], specialization: 'general_mathematics', training_status: 'completed', training_progress: 100, use_math_pipeline: true\n    });\n  }\n  return ai;\n}\n